{"version":3,"file":"instancing_billboards_test.js","sourceRoot":"","sources":["instancing_billboards_test.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference path=\"typings/index.d.ts\" />\n\nclass InstancingBalls{\n\n    public scene: THREE.Scene;\n    public camera: THREE.Camera;\n    private renderer:THREE.WebGLRenderer;\n    private noise:Object;\n    private time:Float32Array;\n\n    private geometry:THREE.InstancedBufferGeometry;\n    private material:THREE.RawShaderMaterial;\n    private mesh:THREE.Mesh;\n    private translateArray:Float32Array;\n    private particleCount:number;\n\n\n\n    private WIDTH:number;\n    private PARTICLES:number;\n\n\n\n    private gpuCompute:any;\n    private velocityVariable:any;\n    private positionVariable:any;\n    private positionUniforms:any;\n    private velocityUniforms:any;\n    private particleUniforms:any;\n    private effectController:any;\n\n    private translateArray:number[] = [];\n\n\n    constructor(renderer:THREE.WebGLRenderer) {\n\n        // renderer.setClearColor(0xffffff);\n        this.renderer = renderer;\n        this.createScene();\n\n        let width = 100;\n        this.WIDTH = width;\n        this.PARTICLES =  width * width;\n\n        this.initPosition();\n        this.initComputeRenderer();\n\n\n\n\n\n\n\n    }\n\n    private initComputeRenderer()\n    {\n\n\n\n        // gpgpuオブジェクトのインスタンスを格納\n        this.gpuCompute = new GPUComputationRenderer( this.WIDTH, this.WIDTH, this.renderer );\n\n        // 今回はパーティクルの位置情報と、移動方向を保存するテクスチャを2つ用意します\n        var dtPosition = this.gpuCompute.createTexture();\n        var dtVelocity = this.gpuCompute.createTexture();\n\n        // テクスチャにGPUで計算するために初期情報を埋めていく\n        this.fillTextures( dtPosition, dtVelocity );\n\n        // shaderプログラムのアタッチ\n        this.velocityVariable = this.gpuCompute.addVariable( \"textureVelocity\", document.getElementById( 'computeShaderVelocity' ).textContent, dtVelocity );\n        this.positionVariable = this.gpuCompute.addVariable( \"texturePosition\", document.getElementById( 'computeShaderPosition' ).textContent, dtPosition );\n\n        // 一連の関係性を構築するためのおまじない\n        this.gpuCompute.setVariableDependencies( this.velocityVariable, [ this.positionVariable, this.velocityVariable ] );\n        this.gpuCompute.setVariableDependencies( this.positionVariable, [ this.positionVariable, this.velocityVariable ] );\n\n        var error = this.gpuCompute.init();\n        if ( error !== null ) {\n            console.error( error );\n        }\n\n    }\n\n    private initPosition() {\n        // this.geometry = new THREE.BufferGeometry();\n        // var positions = new Float32Array( this.PARTICLES * 3 );\n        // var p = 0;\n        // for ( var i = 0; i < this.PARTICLES; i++ ) {\n        //     positions[ p++ ] = 0;\n        //     positions[ p++ ] = 0;\n        //     positions[ p++ ] = 0;\n        // }\n        //\n        // // uv情報の決定。テクスチャから情報を取り出すときに必要\n        // var uvs = new Float32Array( this.PARTICLES * 2 );\n        // p = 0;\n        // for ( var j = 0; j < this.WIDTH; j++ ) {\n        //     for ( var i = 0; i < this.WIDTH; i++ ) {\n        //         uvs[ p++ ] = i / ( this.WIDTH - 1 );\n        //         uvs[ p++ ] = j / ( this.WIDTH - 1 );\n        //     }\n        // }\n        //\n        // // attributeをgeometryに登録する\n        // this.geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n        // this.geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n        //\n        //\n        // // uniform変数をオブジェクトで定義\n        // // 今回はカメラをマウスでいじれるように、計算に必要な情報もわたす。\n        // this.particleUniforms = {\n        //     texturePosition: { value: null },\n        //     textureVelocity: { value: null },\n        //     cameraConstant: { value: this.getCameraConstant( this.camera ) },\n        //     map: { value: new THREE.TextureLoader().load( \"texture/circle.png\" ) },\n        // };\n        //\n        //\n        //\n        // // Shaderマテリアル これはパーティクルそのものの描写に必要なシェーダー\n        // var material = new THREE.ShaderMaterial( {\n        //     uniforms:       this.particleUniforms,\n        //     vertexShader:   document.getElementById( 'particleVertexShader' ).textContent,\n        //     fragmentShader: document.getElementById( 'particleFragmentShader' ).textContent\n        // });\n        // material.extensions.drawBuffers = true;\n        // var particles = new THREE.Points( this.geometry, material );\n        // particles.matrixAutoUpdate = false;\n        // particles.updateMatrix();\n\n        // パーティクルをシーンに追加\n        // this.scene.add( particles );\n\n        var uvs = new Float32Array( this.PARTICLES * 2 );\n        var p = 0;\n        for ( var j = 0; j < this.WIDTH; j++ ) {\n            for ( var i = 0; i < this.WIDTH; i++ ) {\n                uvs[ p++ ] = i / ( this.WIDTH - 1 );\n                uvs[ p++ ] = j / ( this.WIDTH - 1 );\n            }\n        }\n\n\n\n        this.particleUniforms = {\n            texturePosition: { value: null },\n            textureVelocity: { value: null },\n            time: { value: 0.0 },\n            cameraConstant: { value: this.getCameraConstant( this.camera ) },\n            map: { value: new THREE.TextureLoader().load( \"texture/circle.png\" ) },\n        };\n\n\n        this.geometry = new THREE.InstancedBufferGeometry();\n        this.geometry.copy( new THREE.BoxBufferGeometry( 1, 1,1,2,2 ) );\n        // var particleCount = 75000;\n        this.translateArray = new Float32Array( this.PARTICLES * 4 );\n        for ( var i = 0, i3 = 0, l = this.PARTICLES; i < l; i ++, i3 += 4 ) {\n            this.translateArray[ i3 + 0 ] = (Math.random() * 2 - 1)*500;\n            this.translateArray[ i3 + 1 ] = (Math.random() * 2 - 1)*500;\n            this.translateArray[ i3 + 2 ] = (Math.random() * 2 - 1)*500;\n            this.translateArray[ i3 + 3 ] = 0;\n        }\n        this.geometry.addAttribute( \"translate\", new THREE.InstancedBufferAttribute( this.translateArray, 4, 1 ) );\n        this.geometry.addAttribute( 'uv_gpu', new THREE.InstancedBufferAttribute( uvs, 2 ) );\n        this.material = new THREE.RawShaderMaterial( {\n            uniforms:this.particleUniforms,\n            vertexShader: document.getElementById( 'vshader_billboard' ).textContent,\n            fragmentShader: document.getElementById( 'fshader_billboard' ).textContent,\n            depthTest: true,\n            depthWrite: true,\n            // transparent:true,\n            // blending:THREE[ \"NormalBlending\" ]\n        } );\n        this.mesh = new THREE.Mesh( this.geometry, this.material );\n        // this.mesh.scale.set( 500, 500, 500 );\n        this.scene.add( this.mesh );\n\n    }\n\n    private fillTextures( texturePosition, textureVelocity ) {\n\n        // textureのイメージデータをいったん取り出す\n        var posArray = texturePosition.image.data;\n        var velArray = textureVelocity.image.data;\n\n        // パーティクルの初期の位置は、ランダムなXZに平面おく。\n        // 板状の正方形が描かれる\n\n        for ( var k = 0, kl = posArray.length; k < kl; k += 4 ) {\n            // Position\n            var _x, _y, _z, _w;\n            _x = this.translateArray[k];\n            _z = this.translateArray[k+1];\n            _y = this.translateArray[k+2];\n            _w = this.translateArray[k+3];\n            // posArrayの実態は一次元配列なので\n            // x,y,z,wの順番に埋めていく。\n            // console.log(_x);\n            // wは今回は使用しないが、配列の順番などを埋めておくといろいろ使えて便利\n            posArray[ k + 0 ] = _x;\n            posArray[ k + 1 ] = _y;\n            posArray[ k + 2 ] = _z;\n            posArray[ k + 3 ] = 50.0;\n\n            // 移動する方向はとりあえずffffffランダムに決めてみる。\n            // これでランダムな方向にとぶパーティクルが出来上がるはず。\n            let randomVelRange = 100;\n            velArray[ k + 0 ] = Math.random()*randomVelRange-randomVelRange/2;\n            velArray[ k + 1 ] = Math.random()*randomVelRange-randomVelRange/2;\n            velArray[ k + 2 ] = Math.random()*randomVelRange-randomVelRange/2;\n            velArray[ k + 3 ] = Math.random()*randomVelRange-randomVelRange/2;\n        }\n    }\n\n    private getCameraConstant( camera ) {\n        return window.innerHeight / ( Math.tan( THREE.Math.DEG2RAD * 0.5 * camera.fov ) / camera.zoom );\n    }\n\n\n    // シーンを作る。ここでオブジェクトを格納していく。\n    private createScene(){\n\n        this.time = new Float32Array(1);\n        this.time[0] = 0.0;\n        this.noise = new SimplexNoise();\n\n\n        // シーンを作る\n        this.scene = new THREE.Scene();\n\n        // カメラを作成\n        this.camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 10000 );\n        this.camera.position.z = 1400;\n        // this.camera.position.y = 20;\n\n        this.renderer.setClearColor(new THREE.Color(0x000000));\n\n\n        // this.geometry = new THREE.InstancedBufferGeometry();\n        // this.geometry.copy( new THREE.CircleBufferGeometry( 1, 6 ) );\n        //\n        // this.particleCount = 10000;\n        //\n        // this.translateArray = new Float32Array( this.particleCount * 4 );\n        //\n        //\n        // // (r sinsθ cosΦ, r cosθ, r sinθ sinΦ)\n        // // var theta = Math.PI*2*Math.random();\n        // // var phi = Math.PI*2*Math.random();\n        // let r = 0.1;\n        //\n        // for ( let i = 0, i3 = 0, l = this.particleCount; i < l; i ++, i3 += 4 ) {\n        //     var theta = Math.PI*2*Math.random();\n        //     var phi = Math.PI*2*Math.random();\n        //     let x = r * Math.sin(theta) * Math.cos(phi);\n        //     let y = r * Math.cos(theta);\n        //     let z = r * Math.sin(theta) * Math.sin(phi);\n        //\n        //     this.translateArray[ i3 + 0 ] = x;\n        //     this.translateArray[ i3 + 1 ] = y;\n        //     this.translateArray[ i3 + 2 ] = z;\n        //     this.translateArray[ i3 + 3 ] = 0.0;\n        //\n        // }\n        //\n        // this.geometry.addAttribute( \"translate\", new THREE.InstancedBufferAttribute( this.translateArray, 4, 1 ) );\n        //\n        // this.material = new THREE.RawShaderMaterial( {\n        //     uniforms: {\n        //         map: { value: new THREE.TextureLoader().load( \"texture/circle.png\" ) },\n        //         time: { value: 0.0 }\n        //     },\n        //     vertexShader: document.getElementById( 'vshader_billbords' ).textContent,\n        //     fragmentShader: document.getElementById( 'fshader_billbords' ).textContent,\n        //     depthTest: true,\n        //     depthWrite: true\n        //\n        //\n        // } );\n        //\n        //\n        // // this.geometry.addAttribute.translate.dynamic = true;\n        //\n        // this.mesh = new THREE.Mesh( this.geometry, this.material );\n        // this.mesh.scale.set( 500, 500, 500 );\n        // this.scene.add( this.mesh );\n\n        this.renderer.setPixelRatio( window.devicePixelRatio );\n        this.renderer.setSize( window.innerWidth, window.innerHeight );\n\n\n        let controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );\n\n\n        // console.log(this.geometry);\n\n\n    }\n\n\n    public click()\n    {\n\n    }\n\n    public keyDown()\n    {\n\n    }\n    // ワンフレームごとの処理\n    public update() {\n\n\n\n        // this.time[0] = performance.now()* 0.0005;\n        //\n        // this.material.uniforms.time.value = this.time[0];\n        //\n        // // this.mesh.rotation.x = this.time * 0.2;\n        // // this.mesh.rotation.y = this.time * 0.4;\n        //\n        // this.geometry.attributes.translate.dynamic = true;\n        // let _array = this.geometry.attributes.translate.array;\n        // for ( let i = 0, i3 = 0, l = _array.length; i < l; i ++, i3 += 4 ) {\n        //     // var theta = Math.PI*2*Math.random();\n        //     // var phi = Math.PI*2*Math.random();\n        //     // let x = r * Math.sin(theta) * Math.cos(phi);\n        //     // let y = r * Math.cos(theta);\n        //     // let z = r * Math.sin(theta) * Math.sin(phi);\n        //\n        //     // translateArray[ i3 + 0 ] = x;\n        //     // translateArray[ i3 + 1 ] = y;\n        //\n        //     _array[ i3 + 3 ] += 0.0001;\n        //     // console.log(_array[ i3 + 0 ]);\n        //\n        // }\n        //\n        // this.geometry.attributes.translate.needsUpdate = true;\n\n        this.gpuCompute.compute();\n\n        // Three.js用のGPGPUライブラリでは、以下のように情報を更新することができる。\n        // 現在の情報を、保存用のメモリに格納するおまじない。\n        this.particleUniforms.texturePosition.value = this.gpuCompute.getCurrentRenderTarget( this.positionVariable ).texture;\n        this.particleUniforms.textureVelocity.value = this.gpuCompute.getCurrentRenderTarget( this.velocityVariable ).texture;\n        // renderer.render( scene, camera );\n        this.particleUniforms.time.value += 0.01;\n\n\n\n\n    }\n\n\n}\n\n\n"]}